package core.communication.access.esb;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

import com.ecc.emp.core.EMPException;
import common.util.SFConst;

import core.communication.tcpip.CommProcessor;
import core.log.SFLogger;

/**
 * 
 * 【类名】EMP提供的TCP/IP通讯协议处理。
 * <p>
 * 类功能说明：
 * 
 * <pre>
 * 渠道接入通讯协议处理
 * </pre>
 * 
 * 使用说明：
 * 
 * <pre>
 * </pre>
 * 其他说明：
 * 
 * <pre>
 * </pre>
 * 参数说明：
 * 
 * <pre>
 * 类成员变量说明
 * </pre>
 * 
 * @author 邹磊
 * @since 1.0 2017-09-14
 * @version 1.0
 */
public class ESBCommProcessor implements CommProcessor {

	/**
	 * 报文长度字段的长度
	 */
	int lengthHeadLen = 8;

	/**
	 * 报文长度的表示方法，0为ASCII方式，1为二进制方式
	 */
	int lengthHeadType = 0;

	/**
	 * 从输入流中读取数据包，并进行通讯协议处理。 若最前面有若干位报文长度，则从输入流中读取相应长度； 否则读到没有数据位为止。
	 * 
	 * @param in
	 *            tcp/ip输出流
	 * @return 读取到的报文
	 * @throws IOException
	 * @throws EMPException
	 */
	public byte[] readPackage(InputStream in) throws IOException, EMPException {

		SFLogger.info(SFConst.DEFAULT_TRXCODE, null, "ESB业务系统接入，TCPIP开始收报文...");

		int contentLength = 0;
		if (this.lengthHeadLen != 0) { // 获得报文长度

			byte[] lenHeadBuf = new byte[lengthHeadLen];
			int off = 0;
			try {
				while (off < lengthHeadLen) {
					off = off + in.read(lenHeadBuf, off, lengthHeadLen - off);
					if (off < 0) {
						throw new EMPException(
								"Socket was closed! while reading!");
					}
				}
			} catch (java.net.SocketTimeoutException ste) {
				SFLogger.error(SFConst.DEFAULT_TRXCODE, null,"业务系统接入，读取数据包[超时]，这个是系统自身保护机制，socket在建立连接后20s内没有收到任何报文就关闭该socket连接。",ste);
				throw ste;
			}

			SFLogger.info(SFConst.DEFAULT_TRXCODE, null, "业务系统接入，收到报文长度:["
					+ new String(lenHeadBuf) + "]");

			if (lengthHeadType == 0) { // ascii
				contentLength = Integer.parseInt(new String(lenHeadBuf).trim());
			} else { // bin
				for (int i = lengthHeadLen - 1; i >= 0; i--) {
					int value = (int) (lenHeadBuf[i] & 0xff);
					contentLength = contentLength * 256 + value;
				}
			}
		} else { // 没有报文长度字段

			contentLength = -1;
		}

		byte[] contentBuf = null;
		if (contentLength < 0) { // 如果没有可参照的报文长度，则循环读取直到读取到末尾
			ByteArrayOutputStream swapStream = new ByteArrayOutputStream();
			byte[] buff = new byte[100]; // buff用于存放循环读取的临时数据
			int rc = 0;
			while ((rc = in.read(buff, 0, 100)) > 0) {
				swapStream.write(buff, 0, rc);

				if (rc < 100) {
					break;
				}
				buff = new byte[100];
			}
			contentBuf = swapStream.toByteArray();
		} else if (contentLength > 0) { // 否则按照长度读取
			int off = 0;
			contentBuf = new byte[contentLength];
			while (off < contentLength) {
				int len = in.read(contentBuf, off, contentLength - off);
				if (len <= 0) {
					break;
				}
				off = off + len;
			}
		} else {
			SFLogger.info(SFConst.DEFAULT_TRXCODE, null,"业务系统接入，读取报文失败!");
			throw new EMPException("业务系统接入，读取报文失败!");
		}

		SFLogger.info(SFConst.DEFAULT_TRXCODE, null, "业务系统接入，TCPIP收到报文内容：["	+ new String(contentBuf) + "]");
		return contentBuf;
	}

	/**
	 * 由于存管业务系统发起的报文头中响应信息长度不同于其他系统，在此接入需要处理 存管响应信息长度=150，其他业务系统响应信息长度=100
	 * 
	 * @param msg
	 * @return
	 */
	public byte[] swapMessagePackage(byte[] msg) {
		byte[] bt = new byte[6];
		System.arraycopy(msg, 0, bt, 0, 6);
		String transCode = new String(bt);
		byte[] buf = new byte[msg.length - 50];
		System.arraycopy(msg, 0, buf, 0, 112);
		System.arraycopy(msg, 162, buf, 112, buf.length - 112);
		SFLogger.info(SFConst.DEFAULT_TRXCODE, null, "业务系统接入(存管接入),报文内容：["+ new String(buf) + "]");
		return buf;
	}

	/**
	 * 根据通讯协议对数据包进行打包，加入通讯协议头（报文长度）。
	 * 
	 * @param msg
	 *            待发送的数据包
	 * @return 加入通讯协议头的数据包
	 */
	public byte[] wrapMessagePackage(byte[] msg) {

		if (msg == null)
			return msg;

		if (this.lengthHeadLen == 0)
			return msg;

		int length = msg.length;
		byte[] buf = new byte[length + this.lengthHeadLen];
		System.arraycopy(msg, 0, buf, lengthHeadLen, length);

		if (this.lengthHeadType == 0) { // ascii
			String lenValue = String.valueOf(length);
			for (int i = 0; i < lengthHeadLen; i++)
				buf[i] = '0';
			int idx = 0;
			for (int i = lengthHeadLen - lenValue.length(); i < lengthHeadLen; i++) {
				buf[i] = (byte) lenValue.charAt(idx++);
			}
		} else { // bin
			int l = length;
			for (int i = 0; i < lengthHeadLen; i++) {
				buf[i] = (byte) (l % 256);
				l = l / 256;
			}
		}
//		SFLogger.info(SFConst.DEFAULT_TRXCODE, null, "业务系统接入，TCPIP返回报文内容：["+ new String(buf) + "]");
		return buf;
	}

	public int getLengthHeadLen() {
		return lengthHeadLen;
	}

	public void setLengthHeadLen(int lengthHeadLen) {
		this.lengthHeadLen = lengthHeadLen;
	}

	public int getLengthHeadType() {
		return lengthHeadType;
	}

	public void setLengthHeadType(int lengthHeadType) {
		this.lengthHeadType = lengthHeadType;
	}

}
